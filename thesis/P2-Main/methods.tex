\chapter{Methods}
This chapter contains a description of the methods used in describing the hardware on the FPGA side using \clash{} and VHDL. The description of the host-side (HPS) programming is included in appendix \ref{app:data_io}, as even though this part of the project is crucial for obtaining results, it is merely tangential to the project goals. The methods are ordered chronologically in order to properly describe the process that lead to the FPGA side programming used in chapter \ref{s:results}. This approach has as side effect that the explanation of the source code is evaluated lazily: only whenever necessary. Therefore the IO system is only covered after testing and synthesis, as it is not yet needed before.

\section{Overall structure}
In any reasonably complex project it pays off to keep a clear structure: it improves understandability and allows for easier debugging. For simple projects in \clash{}, the structure would be uniquely determined by the HDL generated by \clash{}, but this project also relies on other sources of HDL. Most noteworthy, the interface between the HPS and the FPGA; these signals are very specific to the type of the FPGA and the interconnects it has to the HPS. Luckily, the vendor (Altera) provides a way to generate HDL (the QSys system) in order to create a bridge from the host code running on the HPS to the programmable hardware, the FPGA. This process is described in appendix \ref{app:data_io_setup}. After configuring the bridge, VHDL can be generated and we are left with an instantiable VHDL component. However, even though \clash{} is capable of instantializing external IP components written in VHDL \cite{CLaSHBlogTut}, the most sensible way of implementing such a structure (due to the easy extensibility) is by writing a specific connecting component in VHDL, which can instantiate the \clash{}-generated VHDL. The only responsibility of the connecting component is to distribute and forward signals: it should not perform any computation. It would be a straightforward process of generating such a connecting component based on the signal names in the top-level entities of the components it instantiates, however, due to the fact that it does not change for different designs and it is not very large, the connecting component has been written by hand in VHDL. Figure \ref{f:large_structure} depicts an overview schematic of the complete system, including both the FPGA and HPS side.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{mealy_machine}
	\caption{TODO FIX ENTER GRAPHIC OF STRUCTURE WITH ILLUSTRATOR}
	\label{f:large_structure}
\end{figure}

\section{External types}
Usually, one of the first things to do when setting up a Haskell project is defining types, and using \clash{} forms no difference. It is especially useful to start by defining an input and an output signal. In a project with simple IO requirements the input and output signals would map straight to switches, keys and LEDs for testing purposes, but as the goal is to write data from the host system into the FPGA registers, the input and output signals will be a lot more complicated. The input and output signals from the \clash{}-generated VHDL top entity are shown in listing \ref{lst:clash_io_types}. The input consists of three separate channels: a bidirectional control channel, the actual input channel and some input needed for the output channel. It might appear strange that the output channel requires input, but this is necessary as the communications adhere to a strict master-slave pattern, in which the HPS is the master and the FPGA the slave. The HPS has to indicate whenever it wants to receive the FPGA output (by specifying an address (\code{out_address}) and setting the \code{out_read}-bit). As a consequence of the strict master-slave protocol, there are a lot less output signals than input signals: only the control and output channel can output data. Lastly, there are the keys, switches and LEDs as additional input and output signals. This concludes the type signatures of the input and output signals in \clash{}-Haskell. However, as the goal is to generate actual VHDL, \clash{} requires some additional information for the naming of the ports of the topEntity of the VHDL module. This is specified using the \code{topEntity}-annotation. In this case this annotation is not very interesting and it's merely a restatement of the input and output signal names, but when the \clash{}-generated VHDL should instantiate other VHDL-modules or use multiple clocks, the annotation can become more complex. It is shown in listing \ref{lst:clash_topentity}. 

\lstinputlisting[caption=Input and output signals for CλaSH, label=lst:clash_io_types, firstline=5,lastline=21]{../clash/SolverTypes.hs}
\lstinputlisting[caption=Signal names\, used in the CλaSH-generated topEntity VHDL module, label=lst:clash_topentity, firstline=8,lastline=29]{../clash/Solver.hs}

\section{Internal types}
So far the external types of the \clash{}-code have been covered, but the real work is done by the internal types: the types that keep track of the state of the system and allow it to do useful work. In order to allow for easy modifications to the types upon which the FPGA operates, they have been defined once and have been referenced everywhere else. This in combination with the property of the higher-order functions in \clash{} that they can operate on all vectors, regardless of length ensures that changing some internal types will not break the program.

\subsection{Internal number representation}
The solvers main data type is \code{type Data = SFixed 8 24}. The constructor \code{SFixed 8 24} stands for a signed fixed-point number, with 8 integer bits and 24 fractional bits. It uses the 2's complement signed number representation, meaning that an 8-bit integer part is capable of representing the integers in the range $[-128..127]$. The 24 fractional bits give this number representation a smallest representable unit of $2^{-24}$. This results in accuracy up to the 7th decimal place, which is similar to the IEEE 754 single precision floating point standard when the magnitude of the number represented is larger than 1. However, in contrast to the floating point standard, fixed point numbers guarantee precision up to a certain amount of decimal places, whereas floating point guarantees accuracy for a certain amount of significant figures (within the bounds of the representation).

The main reason for the use of fixed point integers is that \clash{} does not support floating point numbers yet, but additionally, fixed point representations are less demanding on FPGA area and result in a shorter critical path. Furthermore, the reason for choosing the total width of the number representation to be 32-bits is purely convenience: the input and output bridges are also 32 bits wide which allows for transferring a single number per write or read.

\subsection{SystemConstants and SystemState}
The \code{SystemConstants} keep track of the variables that do not change during the process of solving the ODE. It consists of a variety of constants that need values for the integration scheme (\code{maxtime}, \code{timestep} and \code{maxstep}). Furthermore, it may contain custom constants, which are passed to the equation to be approximated. This setup allows for (limited) changes to the equation by changing the constants at run-time without the time-consuming requirement of recompiling the entire FPGA side of the project.

Moving on to the data type which responsible for keeping track of the state of the system: the \code{SystemState}. This type has two fields: the \code{ODEState}, which is has the exact same function as the similarly named type in section \ref{s:numsolHaskell}: it keeps track of the values and the time in the numerical solver. It does this using a \code{valueVector} (of type \code{Vec 4 Data}) and a \code{time} variable (of type \code{Data}). The main difference between the type of the \code{ValueVector} in this implementation of \code{ODEState} and the one in section \ref{s:numsolHaskell} is that this one uses a vector instead of a list. In Haskell, lists can have any length (including infinite) whereas the \clash{}-vectors have a fixed length. This property is very important when generating VHDL, as all vector lengths have to be immutable and known at compile-time in order to compile the higher-order Haskell functions (eg. map) to VHDL and afterwards to hardware. 

The second field of the \code{SystemState} is a counter called \code{step}. Together with the \code{maxstep} field in \code{SystemConstants}, these govern the amount of output generated from the FPGA. A more elaborate explanation of the generation of output can be found in section \ref{s:compute}.

\lstinputlisting[caption=Internal state variables for CλaSH, label=lst:clash_internal_types, firstline=23,lastline=45]{../clash/SolverTypes.hs}

\section{Implementation of equations and integration schemes}
The \clash{}-implementations of the equations and integration schemes can be very similar to the implementations in plain Haskell, from section \ref{s:numsolHaskell}. However, \clash{} does not support any special operations yet (exponentiation, trigonometry or fractional powers) and therefore this imposes limitations on the type of equations which are representable, especially non-linear and heterogeneous equations which use special operations. In order to allow for easy specification without recompilation of a large range of equations, the default equation for testing will be a 4 by 4 matrix vector equation (\ref{eq:testeq}). This set up is capable of representing any linear and homogeneous fourth order equation with constant coefficients as well as lower-order equations with constant heterogeneous parts.

\begin{equation}
\label{eq:testeq}
\begin{bmatrix} x_{0} \\ x_{1} \\ x_{2} \\ x_{3} \end{bmatrix}' 
= 
\begin{bmatrix} 
c_{0} & c_{1} & c_{2} & c_{3} \\ 
c_{4} & c_{5} & c_{6} & c_{7} \\
c_{8} & c_{9} & c_{10} & c_{11} \\
c_{12} & c_{13} & c_{14} & c_{15}
\end{bmatrix} 
\begin{bmatrix} x_{0} \\ x_{1} \\ x_{2} \\ x_{3} \end{bmatrix}
\end{equation}

In order to implement this equation in Haskell (listing \ref{lst:matrix2d} shows the 2 by 2 version), it is certainly possible to use higher order functions, using \code{foldl (+) 0 \$ zipWith (*) matrixRow Vector}. However, this would require the construction of additional vectors. Furthermore, as \clash{} is not yet completely optimizing, in order to obtain the highest possible performance for this hot-zone of the hardware, the decision was made to manually unroll the higher order functions into expressions containing only the unpacking of variables from the \code{SystemConstants} and simple arithmetic operators, $+$ and $*$. 

\lstinputlisting[caption=Implementation of a second order equation with constant coefficients, label=lst:matrix2d, firstline=6,lastline=19]{../clash/SolverEquations.hs}

As for the integration schemes, these are incredibly similar to the implementations from section \ref{s:numsolHaskell}. The first part only contains unpacking of necessary variables from the records. For Euler's method, the actual work integration scheme is only a single line, the remaining lines check whether the time is not yet exceeding the maximum simulation time and generate an \code{ODEState} type, which gets used stored as part of the state in the main controlling logic, from listing \ref{lst:clash_statemachine}. A reference to the controlling logic (the topEntity), the integration schemes and the equations can be found in appendix \ref{app:project_structure}

\lstinputlisting[caption=Euler's method in CλaSH, label=lst:clash_euler, firstline=6,lastline=24]{../clash/SolverSchemes.hs}

\section{Simulation}
After writing the Haskell code which is going to be compiled by \clash{}, it is very easy to simulate your design: \clash{} includes a \code{simulate} function which is capable of generating user-specified signals. Especially in contrast with the process of generating test benches for VHDL, using Haskell to perform simulations saves a lot of time and typing. However, choosing to perform the tests in Haskell over a VHDL testbench does have the underlying assumption that \clash{} properly translates the Haskell specification into VHDL. \clash{} is also capable of generating VHDL testbenches, but this merely shifts the assumption of correctness from \clash{}' ability to generate VHDL to its ability to generate VHDL testbenches, therefore, this option of directly generating VHDL testbenches has not been explored further.

\lstinputlisting[caption=A simulation in CλaSH, label=lst:clash_simulation, firstline=20,lastline=45]{../clash/SolverTest.hs}

The simulations in \clash{} consist of three parts:
\begin{enumeratens}
\item \emph{Signal definitions} - In order to keep the rest of the code concise, it is important to first define often-used signals. For versatility, these signals can even be functions: some values still have to be defined in order to return a signal.
\item \emph{Signal listings} - This is where signals defined in step 1 are put together in order to create a list of signals: the input of the \code{simulate} function.
\item \emph{Simulation} - The \code{simulate} function takes a \code{topEntity} and a list inputs and returns a list of output. Due to the infinite nature of the \code{Signal} in \clash{}, which is fed into the \code{topEntity} as input it is necessary to only take a certain amount of elements. However, as Haskell is evaluated lazily, the infinite lists are not a problem. 
\end{enumeratens}

The output of the simulation is printed to screen, which was checked by eye for grave mistakes. If everything appeared to be correct, the design was ready for synthesis. The reason for such inexactness in verifying by simulation is that (at least for simple) Haskell programs, that they tend to have the property that they either work correctly or they do not work at all. Furthermore, the real trouble in debugging lies in the other parts of the FPGA side of the design: proper clock frequencies and the IO system.

\section{Synthesis and deployment}
After the simulation appears to be correct, \clash{} should generate HDL which can be compiled by the FPGA vendors tools into a binary file which can be used to program the FPGA. The process of synthesis and deployment consists of several steps, of which a short overview is shown below.
\begin{enumeratens}
	\item \emph{Generating HDL } - The \clash{} compiler contains the optional flags \code{--vhdl} and \code{--verilog}. These can be used to generate HDL.
	\item \emph{Project creation} - Set up the external IO systems. These will not be written in \clash{}-generated HDL, but will be generated by another tool. In case of Altera this is the QSys system. Furthermore, add the manually written HDL files, for instance the connecting component and a frequency divider.
	\item \emph{Adding \clash{}-generated files to the project} - Add all \clash{}-generated files: if both the connecting component and the \clash{}-Haskell code were written properly then the connecting component should be able to instantiate the \clash{}-HDL as their ports match.
	\item \emph{Compiling} - After everything has been added and configured properly, start the compilation. For Altera FPGAs, the result will be a \code{.sof} (SDRAM Object File). 
	\item \emph{Deploying} - Use the 'Programmer' feature in order to flash the \code{.sof} to the FPGA.
\end{enumeratens}

The process depicted above is rather high in manual workload as it uses the Quartus GUI. A shell script automatizing the process is described in appendix \ref{app:toolchain_integration}.  

\section{Loading data into the FPGA}
\subsection{Constants}
In order to understand the \clash{} source code, it's important to know what the variables mean. In order to keep the lines relatively short, the variable names are rather short, but they do follow a fixed pattern. All variables starting with \code{i_} indicate input, \code{s_} a state and \code{c_} a constant value. As for the input variables, those consist further out of 1 or 2 characters. The first character indicates the source channel of the input (whether it is a real input : \code{i}, a control signal : \code{c} or a request for output \code{o}). The second optional character is either \code{a}, for address, or \code{s}, for 'set': the boolean indicating that the input is ready to be read. When this second character is missing, the data itself is meant.

\lstinputlisting[caption=Handling the input of the constants, label=lst:clash_constants, firstline=100,lastline=109]{../clash/Solver.hs}

The first step of getting the system to work is loading constants into the FPGA. These constants govern the time step, the maximum time for simulation, how much output to generate and it's possible to specify custom constants which can be used in the equations you are solving. In order to keep the system simple, these constants are sent over the control channel as the input channel is reserved for initial values. However, before covering the specifics of handling the constants, it is important to understand the behaviour of the signals originating from the bridge between the HPS and the FPGA first. Whenever the HPS program writes the 32-bits value $V$ to 8-bit address $A$, three things happen simultaneously, \code{control_writedata} takes on the value $V$, \code{control_address} gets set to address $A$ and \code{control_write} gets set to true. This set up means that it is possible to differentiate the target of the control input signal based on the value of the address. Only whenever \code{control_write} is true the control input value can be considered valid. Lastly, as Haskell is a strongly typed language, you cannot simply insert a \code{BitVector 32}, originating from \code{control_writedata} into a \code{Vec 4 (SFixed 8 24)}. You first have to cast or unpack the \code{BitVector 32} into a \code{SFixed 8 24}, which luckily does not pose any problems as they both consist of 32 bits. The protocol for entering constants is depicted in table \ref{t:control_protocol}.

\begin{table}[h]
	\caption{The protocol for entering constant values into the FPGA, based on addresses}
	\label{t:control_protocol}

	\begin{tabular}{l l l}
		\textbf{Address} & \textbf{Function} &  \textbf{Specifics} \\
		0 	& Signaling flags 			& Writing 1 starts the computation \\
		& 				 				& Writing 2 performs a soft reset \\
		1 	& Maximal computation time 	& \\
		2 	& Time step 				& \\
		3 	& Step limit for blocking	& \\ 
		4+ 	& Custom constants 			& \\
	\end{tabular}
\end{table}

\subsection{Initial values}
The initial values are loaded into the FPGA in the same way as the constants. The address designates the location at which the value should be stored. 
In order to understand how the data gets loaded into the FPGA registers it is important to  If this is the case, the \code{valueVector} of \code{ODEState} in the \code{SystemState} gets updated: the value at \code{in_address} gets replaced with \code{in_writedata}, which gets \code{unpack}'ed into the main data type used by the application. 

\lstinputlisting[caption=State machine responsible for controlling the solver, label=lst:clash_statemachine, firstline=77,lastline=98]{../clash/Solver.hs}



\section{Solving the system and extracting values}
\label{s:compute}
After sending the command to the FGPA to start solving the ODE over the control channel, on every clock cycle the FPGA will update the \code{ODEState} and the \code{step} variable. The \code{ODEState} gets updated by applying an integration scheme to the equation, which results in a new vector of values and a new value for the time. The \code{step} variable gets incremented to indicate that another step has passed. At some point, the value of \code{step} will exceed the value of \code{maxstep}, from \code{SystemConstants}. Whenever this happens, the FPGA stops updating the \code{ODEState} and writes all ones to the output port. This indicates that the FPGA is done processing and the results are ready to be collected by the HPS. 

The \code{step} of \code{SystemState} in listing \ref{lst:clash_internal_types} field takes a bit more explanation. Every time the integration scheme gets applied, the \code{step} variable gets incremented. At some point, the value of \code{step} becomes larger or equal than the \code{maxstep} field from the data type \code{SystemConstants}. Whenever this happens, the system blocks until you order it to start again by setting the value of \code{step} to 0. During the time that the system does not progress, the values of the system can be read. This is done by requesting access to an address from the HPS. This request gets processed by the bridge and the hardware on the FPGA side into a high value for the \code{out_read} input signal, accompanied by a valid address from the \code{out_address} input signal. The FPGA is then responsible for actually writing the requested value to the output channel, in which the \code{out_address} is directly equal to the index in the \code{ValueVector}.