\chapter{Discussion}

\section{Accuracy}
The results presented in this thesis are not highly accurate for all solvers and time steps used. The reason for this is two-fold. Firstly, the thesis is meant to show whether numerical mathematics is a topic which is feasible on an FPGA, which it demonstrably is. Secondly, the number representation used resulted in sub-par results, especially for higher-order integration schemes like RK4. 

However, what has been shown (for certain values of the time step) is an equality between the same solver schemes, implemented in \matlab{} and directly on the FPGA. Therefore, if more advanced schemes are used, together with a number representation which is suitable for a wider class of problems these could lead to results which are of high quality. A more suitable number representation would be double-precision floating point, which has as disadvantage that it is very expensive, computation-wise. Another option would be to simply extend the fixed-point representation, for instance to \code{SFixed 24 40} or, if the FPGA allows, \code{SFixed 32 96}.

\section{Performance}
Table \ref{t:performance} shows that all FPGA implementations lose out to a modern CPU on performing the same operations. Does this mean that FPGAs are not useful in performing numerical mathematics? It certainly doesn't, as there are quite a few remarks to be made on this comparison. First and foremost - the FPGA used in this thesis is an Altera Cyclone 5. According to \cite{AlteraFPGAs}, this series is intended for "low-power, cost-sensitive design needs", whereas the Stratix series is designed for "high-performance". This suggests that use of a Stratix FPGA could clearly improve performance, either by supporting higher clock speeds, by having more hard adders and multipliers or by having more configurable logic elements. Furthermore, due to limitations in \clash{}, the FPGA design did not use a fractional PLL, only an integer frequency divider which was written manually. This meant that Quartus was unable to optimize the clock speed for the design. It may have been possible that the maximum clock speed the 4x4 matrix vector product (as used in Euler's method) supported was higher than the 50 MHz used in testing, which would again, boost the FPGA performance. Additionally, in order to reduce compilation time for repeated testing, the optimizations in the Quartus compiler were disabled, in contrast to the C++ solution, which was produced with the highest optimization settings (\code{-O3}). Without optimizer, the C++ solution performed approximately 4x worse, which would have moved it to the third quartile of the tested FPGA solutions. Furthermore, according to the Quartus compiler, the design only took around 10\% of the FPGA fabric. A quick, approximate calculation based on the number of operations necessary suggests that this FPGA would be capable of performing a 12x12 matrix vector multiplication using 90\% of its area. This would only require a linear decrease in clock speed (a factor 3), whereas the matrix size has grown quadratically, which means that the CPU has to perform 9x as much work. Lastly, CPUs are heavily optimized for integer performance. This can also be seen from table \ref{t:performance}: merely switching the data type from int to float results a decrease in performance of almost 2 orders of magnitude, which indicates that it could be very hard to compete with modern CPUs on integer arithmetic performance. The high performance of CPUs comes at a cost: the total power associated with running a single CPU core at 100\% will be considerably higher \cite{Inteli7} than the maximum power associated with this FPGA: 1.8W \cite{AlteraCycloneV}.

\section{Suggestions for further work}
This thesis has shown the very basics of solving ODEs on FPGAs. A lot of time has been spent on 'engineering challenges', which leaves some topics for future works:
\begin{itemizens}
\item \emph{Including block-ram as data storage} - This allows for more data, larger matrices and possibly even approximations of PDEs, but it could face problems of performance: on larger FPGAs, all data is needed in every cycle whereas the block-ram interfaces have limited bandwidth and a delay of a single cycle per read or write.
\item \emph{Implementations of more advanced integration schemes} -  Adaptive (variable-step) and multi-step methods. These should probably be combined with a different number representation because as shown, for 32-bit fixed point numbers the best implemented method was still Euler's method.
\item \emph{An entirely different application} - Improvement of the IO system. The current IO system is versatile and does not only work for solving ODEs. By changing the \clash{} code and modifying the host code slightly, the functionality can be flexible: quick computation of hashes or a hardware-implemented random-number generator are some of the possibilities.
\end{itemizens}

\section{Suggestions for additions to \clash{}}
\begin{itemizens}
	\item \emph{Floating point numbers} - When an extremely wide fixed point number representation is not possible due to FPGA constraints, floating point arithmetic could be a solution. Furthermore, considering that numerical mathematics is often implemented using floating-point arithmetic (e.g. \matlab{}) it would be important to be able to use \clash{} to implement \matlab{} algorithms with the same results.
	\item \emph{More sample projects} - Short code samples can be found in the \code{clash-compiler} repository and the \code{Hackage} documentation is very complete, but getting started on complex projects can still be hard. This report has been written - both as a BSc thesis and an overview guide on using \clash{}, attempting to cover the process from the beginning: 'What is functional programming' to the end: 'Deploying your design on an FPGA', as my contribution to \clash{}.
	\item \emph{More flexibility for PLL clocks} - Using a single PLL for the \clash{} design works great, but when the \clash{} design is merely a module of a greater project, things start to get hairy. Due to some non-deterministic behaviour of the Altera's own PLL (\code{Altera PLL} in the Quartus IP Library), a frequency divider was implemented manually in VHDL, which was capable of driving both the IO system as well as the \clash{} design, but as the PLL was implemented manually, Quartus could not optimize the design for an optimal frequency which could have resulted in some performance loss. As an addition to \clash{} it would be very helpful if it would be possible to feed the output clock and the locked signal, generated by the PLL module, directly into the \clash{} module.
\end{itemizens}